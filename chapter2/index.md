# 2.1
变位词问题本质上是一个分类的问题，如何把有一定规律的元素归类到一起。这里作者给出了一个通用方案，就是首先按照规律对词进行计算，得到一个特定的key，同为变位词的单词计算得到的key是相同的，这样就可以通过对key排序从而完成分类。这种方式还是很有启发性的，当我们不能直接对比原始数据的时候，先思考一下这些数据的共性和规律，然后看能不能通过计算让它们转换成可比较的形式。

回到这个问题，这里有两种情况：
1，单词是一个个给出的，给完最后一个单词的时候，要求能给出给定单词的所有变位词。
2，词典是预先给出的，要求给出给定单词的所有变位词。

第一种情况我们先计算给定单词的规范化表示，例如word，规范化为：d1o1r1w1（字母 + 出现次数，字母按照字母序排序）。然后对随后给出的每个单词都计算其规范化表示，把规范化表示和word一样的都加入到结果集即可。

第二种情况，因为我们可以预先读入整个词典，所以我们可以先构造一个hash map，其中key是单词的规范化表示，value是符合此规范化表示的所有单词集合。这样我们得到一个单词之后，就可以直接计算规范化表示，然后通过map得到所有变位词集合。

# 2.2
首先我们先回顾一下作者是如何通过二分的方式来处理这种：N个数字中，缺少一个，找到这个缺少的数字的问题。
作者的思路是这样的，因为N < 2^32，所以一定会有至少一个数字缺少了。常规情况下，找到缺少的那个数字，只需要对数字排序(使用之前的bitset)，然后遍历一遍找到缺失的那个即可。

但是实际实现的时候，往往有CPU、内存、存储等多方面的限制。使用bitset存储2^32个数字，需要4GB的内存。如果我们没有那么大的内存，就没办法能一次把所有给定的数字都排好序。这个时候我们就需要对处理的域进行划分，缩小我们要处理的数据量。作者的思路是：
按照数字的第1个bit为0还是1，将这些数字划分为两份，然后我们统计这两份文件中的数字数量。一定会有一份的数字数量小于2^31，那么这个更小的数据集中也一定存在着缺少的数字。通过这样的划分，我们每次都可以将数据集减半。（另一半中虽然也可能会有缺少的数字，但是我们目标是只找一个缺少的数字，所以我们可以不用管另一半数据的情况了）

这种情况下我们处理的数字数为：N + N / 2 + N / 4 + ... + N / (2^k)，复杂度为O(NlogN)

# 2.3
本题要求实现向量的旋转，比如说"abcdefghijklmnopqrstuvwxyz"这样的字符串，向左旋转3位，就变成了"defghijklmnopqrstuvwxyzabc"。书中讲了5种实现的方案，比如要旋转的长度为i，总长度为n：

1. 分配一块长为i的内存temp，这样只需要先copy array[i] -> temp，然后再copy array[n - i] -> array[i]，最后再copy temp -> array[n - i + 1]。这样空间复杂度是O(i)，时间复杂度是O(1)。在工程上也常常采用这种方式，不过作者认为这种方式可能会用到的存储比较多。

2. 最朴素的做法，每次把所有元素左移1次（需要操作n个元素，复杂度是O(n)），然后重复i次即可，这样空间复杂度是O(1)，时间复杂度是O(i * n)。

3. 是上面那种方法的改进版，上面这种方法的问题在于，每个元素每次只移动一个位置，这样的移动是低效的，其实只要确定了i，每个元素就应该向左移i个位置。这种方式就是每个元素直接移动i个位置，所以综合下来，空间复杂度是O(1)，时间复杂度是O(n)。

4. 一种递归二分的思想。先把array分为a | b两部分，我们的目标就是把ab -> ba。a和b中较长的那个，又可以分成两个，比如len(a) < len(b)，那么我们可以把ab看作a | b1 | b2，其中len(a) == len(b2)，这样我们先交换a和b2，这样就变成了b2 | b1 | a，我们最终的目标是要变成b1 | b2 | a，所以我们的问题就可以递归下去了，变成交换b1 | b2的位置了。

5. 一种通过类比得到的算法。类比了数学中的求逆，ab变成ba，可以这样完成 ab -> a'b' -> (a'b')' = ba，其中a'表示求a的逆。

本题我们实现后三种算法，前两种算法比较简单，就不做了，代码见[2_3](./src/2_3.cpp)

注意这里题目中还特别让我们留意最大公约数在这些实现中的作用。我们需要思考一下这个问题和最大公约数有什么关系。